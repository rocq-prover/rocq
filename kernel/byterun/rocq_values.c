/***********************************************************************/
/*                                                                     */
/*                          Rocq Compiler                              */
/*                                                                     */
/*        Benjamin Gregoire, projets Logical and Cristal               */
/*                        INRIA Rocquencourt                           */
/*                                                                     */
/*                                                                     */
/***********************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <caml/memory.h>
#include "rocq_fix_code.h"
#include "rocq_instruct.h"
#include "rocq_memory.h"
#include "rocq_values.h"
#include <memory.h>
/* KIND OF VALUES */

#define Setup_for_gc
#define Restore_after_gc

#define Is_instruction(c, i) rocq_is_instruction(*c, i)

value rocq_kind_of_closure(value v) {
  opcode_t * c;
  int is_app = 0;
  c = Code_val(v);
  if (Is_instruction(c, GRAB)) return Val_int(0);
  if (Is_instruction(c, RESTART)) {is_app = 1; c++;}
  if (Is_instruction(c, GRABREC)) return Val_int(1+is_app);
  if (Is_instruction(c, MAKEACCU)) return Val_int(3);
  return Val_int(0);
}

value rocq_is_accumulate_code(value code)
{
  code_t q = Code_val(code);
  int res;
  res = Is_instruction(q,ACCUMULATE);
  return Val_bool(res);
}

/* DESTRUCT ACCU */

value rocq_closure_arity(value clos) {
  opcode_t * c = Code_val(clos);
  if (Is_instruction(c,RESTART)) {
    c++;
    if (Is_instruction(c,GRAB)) return Val_int(4 + c[1] - Wosize_val(clos));
    else {
      if (Wosize_val(clos) != 3) caml_failwith("Rocq Values : rocq_closure_arity");
      return Val_int(1);
    }
  }
  if (Is_instruction(c,GRAB)) return Val_int(1 + c[1]);
  return Val_int(1);
}

/* Fonction sur les  fix */

value rocq_current_fix(value v) {
  if (Tag_val(v) == Closure_tag) return Val_int(0);
  else return Val_long(Wsize_bsize(Infix_offset_val(v)) / 3);
}

value rocq_shift_fix(value v, value offset) {
  return v + Int_val(offset) * 3 * sizeof(value);
}

value rocq_last_fix(value v) {
  return v + (Int_val(Field(v, 1)) - 2) * sizeof(value);
}

value rocq_set_bytecode_field(value v, value i, value code) {
  // No write barrier because the bytecode does not live on the OCaml heap
  Field(v, Long_val(i)) = (value) Code_val(code);
  return Val_unit;
}

value rocq_offset_tcode(value code,value offset){
  CAMLparam1(code);
  CAMLlocal1(res);
  res = caml_alloc_small(1, Abstract_tag);
  Code_val(res) = Code_val(code) + Int_val(offset);
  CAMLreturn(res);
}

value rocq_int_tcode(value pc, value offset) {
  code_t code = Code_val(pc);
  return Val_int(*((code_t) code + Int_val(offset)));
}

value rocq_tcode_array(value tcodes) {
  CAMLparam1(tcodes);
  CAMLlocal2(res, tmp);
  int i;
  /* Assumes that the vector of types is small. This was implicit in the
    previous code which was building the type array using Alloc_small. */
  res = caml_alloc_small(Wosize_val(tcodes), Default_tag);
  for (i = 0; i < Wosize_val(tcodes); i++) {
    tmp = caml_alloc_small(1, Abstract_tag);
    Code_val(tmp) = (code_t) Field(tcodes, i);
    Store_field(res, i, tmp);
  }
  CAMLreturn(res);
}

/* The following architecture-dependent function returns a core pointer
   (wrapped in an option) that can be used as field 0 of an OCaml closure.
   But since the word before the start of the code contains a header that
   causes it to be ignored by the garbage collector, the pointer can even be
   put inside closures that do not have tag 247.

   The code itself translates the call "foo x" (i.e., "%apply x foo") into
   "accumulate foo.2 x". The first few instructions are those generated by
   the OCaml compiler for the closure returned by the following partial
   application:

   let foo data = accumulate data (* in Nativevalues *)

   The last few instructions invoke the code pointer stored in rocq_accumulate_addr.
   This variable is initialized using field 2 of the closure passed as parameter
   (i.e., "accumulate"), which is the pointer to the arity-2 direct call. */

#if defined(__GNUC__) && defined(__amd64__)
static code_t rocq_accumulate_addr asm("rocq_accumulate_addr") __attribute__((used));

value rocq_proxy_accu(value clos) {
  value v;
  CAMLassert(Tag_val(clos) == Closure_tag && Arity_closinfo(Closinfo_val(clos)) == 2);
  rocq_accumulate_addr = ((code_t *)clos)[2];
  asm("jmp 1f\n\t"
      ".align 8\n\t"
      ".quad 3067\n"
      "2:\n\t"
      "mov %%rax, %%rdi\n\t"
      "mov 16(%%rbx), %%rax\n\t"
      "mov %%rdi, %%rbx\n\t"
      "lea rocq_accumulate_addr(%%rip), %%rdi\n\t"
      "jmp *(%%rdi)\n"
      "1:\n\t"
      "lea 2b(%%rip), %0\n\t"
      : "=r"(v));
  value r = caml_alloc_small(1, 0);
  Field(r, 0) = v;
  return r;
}

#elif defined(__GNUC__) && defined(__i386__)
static code_t rocq_accumulate_addr asm("rocq_accumulate_addr") __attribute__((used));

value rocq_proxy_accu(value clos) {
  value v;
  CAMLassert(Tag_val(clos) == Closure_tag && Arity_closinfo(Closinfo_val(clos)) == 2);
  rocq_accumulate_addr = ((code_t *)clos)[2];
  asm("jmp 1f\n\t"
      ".align 4\n\t"
      ".long 3067\n"
      "2:\n\t"
      "mov %%eax, %%ecx\n\t"
      "mov 8(%%ebx), %%eax\n\t"
      "mov %%ecx, %%ebx\n\t"
      "call __x86.get_pc_thunk.cx\n\t"
      "add $_GLOBAL_OFFSET_TABLE_, %%ecx\n\t"
      "mov rocq_accumulate_addr@GOT(%%ecx), %%ecx\n\t"
      "jmp *(%%ecx)\n"
      "1:\n\t"
      "call __x86.get_pc_thunk.ax\n\t"
      "add $_GLOBAL_OFFSET_TABLE_, %%eax\n\t"
      "lea 2b@GOTOFF(%%eax), %0\n\t"
      : "=r"(v) : : "eax");
  value r = caml_alloc_small(1, 0);
  Field(r, 0) = v;
  return r;
}

#else
value rocq_proxy_accu(value) {
  return 1;
}
#endif
